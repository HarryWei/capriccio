Files linux-2.5.70/drivers/atm/pca200e.bin and linux-2.5.70-eepoll/drivers/atm/pca200e.bin differ
diff -Nru linux-2.5.70/fs/aio.c linux-2.5.70-eepoll/fs/aio.c
--- linux-2.5.70/fs/aio.c	2003-05-26 18:00:39.000000000 -0700
+++ linux-2.5.70-eepoll/fs/aio.c	2003-07-02 02:25:46.000000000 -0700
@@ -15,7 +15,7 @@
 #include <linux/aio_abi.h>
 #include <linux/module.h>
 
-//#define DEBUG 1
+#define DEBUG 2
 
 #include <linux/sched.h>
 #include <linux/fs.h>
@@ -344,7 +344,8 @@
 
 		if (1 != atomic_read(&ctx->users))
 			printk(KERN_DEBUG
-				"exit_aio:ioctx still alive: %d %d %d\n",
+				"[%p] exit_aio:ioctx (%p) still alive: %d %d %d\n",
+				current, ctx,
 				atomic_read(&ctx->users), ctx->dead,
 				ctx->reqs_active);
 		put_ioctx(ctx);
@@ -366,7 +367,8 @@
 	aio_free_ring(ctx);
 	mmdrop(ctx->mm);
 	ctx->mm = NULL;
-	pr_debug("__put_ioctx: freeing %p\n", ctx);
+	dprintk("[%p] __put_ioctx: freeing %p\n", current, ctx);
+	show_stack(NULL);
 	kmem_cache_free(kioctx_cachep, ctx);
 
 	atomic_sub(nr_events, &aio_nr);
diff -Nru linux-2.5.70/fs/eventpoll.c linux-2.5.70-eepoll/fs/eventpoll.c
--- linux-2.5.70/fs/eventpoll.c	2003-05-26 18:00:38.000000000 -0700
+++ linux-2.5.70-eepoll/fs/eventpoll.c	2003-07-02 01:37:41.000000000 -0700
@@ -38,11 +38,12 @@
 #include <asm/mman.h>
 #include <asm/atomic.h>
 
-
+#include <linux/aio.h>
+#include <linux/highmem.h>
 
 #define EVENTPOLLFS_MAGIC 0x03111965 /* My birthday should work for this :) */
 
-#define DEBUG_EPOLL 0
+#define DEBUG_EPOLL 3
 
 #if DEBUG_EPOLL > 0
 #define DPRINTK(x) printk x
@@ -164,6 +165,14 @@
 
 	/* Pages for the "struct epitem" hash */
 	char *hpages[EP_MAX_HPAGES];
+
+  /* added by zf for AIO support */
+  /* async io context to wait on */
+  struct kioctx *ioctx;
+  /* whether the io context has pending events */
+  //  int isctxready;
+  /* obscure user data passed in with the event */
+  __u64 aiodata;
 };
 
 /* Wait structure used by the poll hooks */
@@ -204,8 +213,9 @@
 	/* The "container" of this item */
 	struct eventpoll *ep;
 
-	/* The file this item refers to */
-	struct file *file;
+	/* The target this item refers to */
+        /* It's either a "struct file" or "struct iocb" (when event & EPOLLAIO is true) */
+        struct file *file;
 
 	/* The structure that describe the interested events and the source fd */
 	struct epoll_event event;
@@ -274,6 +284,7 @@
 static struct super_block *eventpollfs_get_sb(struct file_system_type *fs_type,
 					      int flags, const char *dev_name,
 					      void *data);
+static int aio_peak_evt(struct kioctx *ioctx);
 
 
 /* Safe wake up implementation */
@@ -504,10 +515,11 @@
 asmlinkage long sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)
 {
 	int error;
-	struct file *file, *tfile;
+	struct file *file, *tfile=0;
 	struct eventpoll *ep;
 	struct epitem *epi;
 	struct epoll_event epds;
+	int isaio = 0;
 
 	DNPRINTK(3, (KERN_INFO "[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %u)\n",
 		     current, epfd, op, fd, event->events));
@@ -522,24 +534,15 @@
 	if (!file)
 		goto eexit_1;
 
-	/* Get the "struct file *" for the target file */
-	tfile = fget(fd);
-	if (!tfile)
-		goto eexit_2;
-
-	/* The target file descriptor must support poll */
-	error = -EPERM;
-	if (!tfile->f_op || !tfile->f_op->poll)
-		goto eexit_3;
-
 	/*
 	 * We have to check that the file structure underneath the file descriptor
 	 * the user passed to us _is_ an eventpoll file. And also we do not permit
 	 * adding an epoll file descriptor inside itself.
 	 */
-	error = -EINVAL;
-	if (file == tfile || !IS_FILE_EPOLL(file))
-		goto eexit_3;
+	if (!IS_FILE_EPOLL(file)) {
+	  error = -EINVAL;
+	  goto eexit_3;
+	}
 
 	/*
 	 * At this point it is safe to assume that the "private_data" contains
@@ -547,6 +550,76 @@
 	 */
 	ep = file->private_data;
 
+	isaio = op & 0x2000;  /* whether this poll is against an fd or an aio context  */
+	if (isaio) {
+	  struct kioctx *kioctx;
+	  op = op & ~(0x2000);
+	  DNPRINTK(3, (KERN_INFO "eepoll: this is processing an aio entry\n"));
+	  /* Check whether the AIO kernel context is valid */
+	  kioctx = lookup_ioctx((unsigned long) fd);
+	  if (!kioctx) {
+	    DNPRINTK(3, (KERN_INFO "eepoll: cannot find the kioctx for %d\n", fd));
+	    error = -EINVAL;
+	    goto eexit_2;
+	  }
+	  switch (op) {
+	  case EPOLL_CTL_ADD:
+	    if (ep->ioctx) {
+	      /* already has one ioctx.  we do not support more than one context */
+	      DNPRINTK(3, (KERN_INFO "eepoll: cannot insert another kioctx when one is already in\n"));
+	      error = -EINVAL;
+              put_ioctx(kioctx);
+	    } else {
+	      ep->ioctx = kioctx;
+	      DNPRINTK(3, (KERN_INFO "eepoll: adding kernel ioctx %p to epoll fd %d\n", kioctx, epfd));
+              // successful addition
+              // we hold a reference to the ioctx
+	    }
+	    break;
+	  case EPOLL_CTL_MOD:
+	    error = -ENOSYS;
+	    DNPRINTK(3, (KERN_INFO "eepoll: modifying a kioctx is not implemented\n"));
+            put_ioctx(kioctx);
+	    break;
+	  case EPOLL_CTL_DEL:
+	    if (ep->ioctx == kioctx) {
+	      ep->ioctx = 0;
+              put_ioctx(kioctx);  // once for ep->ioctx
+              put_ioctx(kioctx);  // twice for the lookup
+	    } else {
+	      DNPRINTK(3, (KERN_INFO "eepoll: trying to delete a nonexistent kioctx\n"));
+	      error = -EINVAL;
+              put_ioctx(kioctx);
+	    }
+	    break;
+	  }
+
+	  error = 0;
+	  ep->aiodata = epds.data;
+
+	  /* we're done */
+	  goto eexit_2;
+
+	} else {
+
+	  /* This is the normal case: epoll for file descriptors */
+	  /* Get the "struct file *" for the target file */
+	  tfile = fget(fd);
+	  if (!tfile)
+	    goto eexit_2;
+	  
+	  /* The target file descriptor must support poll */
+	  error = -EPERM;
+	  if (!tfile->f_op || !tfile->f_op->poll)
+	    goto eexit_3;
+
+	}
+
+	if (file == tfile) {
+	  error = -EINVAL;
+	  goto eexit_3;
+	}
+
 	/*
 	 * Try to lookup the file inside our hash table. When an item is found
 	 * ep_find() increases the usage count of the item so that it won't
@@ -876,6 +949,18 @@
 		}
 	}
 
+        /*
+         * remove the AIO context if registered
+         */
+        if (ep->ioctx) {
+            DNPRINTK(3, (KERN_INFO "[%p] epoll: closing, removing kioctx, ep=%p, ep->ioctx=%p\n", current, ep, ep->ioctx));
+            if (atomic_read(&ep->ioctx->users) <= 0)
+               DNPRINTK(3, (KERN_ERR "[%p] epoll: BUG: kioctx %p has =< 0 users!\n", current, ep->ioctx));
+            else
+               put_ioctx(ep->ioctx);
+            ep->ioctx = 0;
+        }
+
 	up_write(&epsem);
 
 	/* Free hash pages */
@@ -1252,7 +1337,7 @@
 	struct epitem *epi = EP_ITEM_FROM_WAIT(wait);
 	struct eventpoll *ep = epi->ep;
 
-	DNPRINTK(3, (KERN_INFO "[%p] eventpoll: poll_callback(%p) epi=%p ep=%p\n",
+	DNPRINTK(4, (KERN_INFO "[%p] eventpoll: poll_callback(%p) epi=%p ep=%p\n",
 		     current, epi->file, epi, ep));
 
 	write_lock_irqsave(&ep->lock, flags);
@@ -1541,7 +1626,10 @@
 	unsigned long flags;
 	long jtimeout;
 	wait_queue_t wait;
+	wait_queue_t aiowait;
+	int aioready = 0;
 
+	DNPRINTK(3, (KERN_INFO "eventpoll: In ep_poll()\n"));
 	/*
 	 * Calculate the timeout by checking for the "infinite" value ( -1 )
 	 * and the overflow condition. The passed timeout is in milliseconds,
@@ -1554,7 +1642,11 @@
 	write_lock_irqsave(&ep->lock, flags);
 
 	res = 0;
-	if (list_empty(&ep->rdllist)) {
+	if (ep->ioctx)
+	  /* test if the aio context is ready */
+	  aioready = aio_peak_evt(ep->ioctx);
+
+	if (!aioready && list_empty(&ep->rdllist)) {
 		/*
 		 * We don't have any available event to return to the caller.
 		 * We need to sleep here, and we will be wake up by
@@ -1563,6 +1655,11 @@
 		init_waitqueue_entry(&wait, current);
 		add_wait_queue(&ep->wq, &wait);
 
+		if (ep->ioctx) {
+		  init_waitqueue_entry(&aiowait, current);
+		  add_wait_queue(&ep->ioctx->wait, &aiowait);
+		}
+
 		for (;;) {
 			/*
 			 * We don't want to sleep if the ep_poll_callback() sends us
@@ -1576,12 +1673,16 @@
 				res = -EINTR;
 				break;
 			}
-
+			if (ep->ioctx && (aioready = aio_peak_evt(ep->ioctx)))
+			  break;
+			
 			write_unlock_irqrestore(&ep->lock, flags);
 			jtimeout = schedule_timeout(jtimeout);
 			write_lock_irqsave(&ep->lock, flags);
 		}
 		remove_wait_queue(&ep->wq, &wait);
+		if (ep->ioctx)
+		  remove_wait_queue(&ep->ioctx->wait, &aiowait);
 
 		set_current_state(TASK_RUNNING);
 	}
@@ -1591,13 +1692,25 @@
 
 	write_unlock_irqrestore(&ep->lock, flags);
 
+	if (!aioready && ep->ioctx)
+	  aioready = aio_peak_evt(ep->ioctx);
+
+	if (aioready) {
+	  struct epoll_event evt;
+	  evt.events = 0x2000;
+	  evt.data = ep->aiodata;
+	  copy_to_user(events, &evt, sizeof(evt));
+	  events++;
+	  res = 1;
+	}
+
 	/*
 	 * Try to transfer events to user space. In case we get 0 events and
 	 * there's still timeout left over, we go trying again in search of
 	 * more luck.
 	 */
-	if (!res && eavail &&
-	    !(res = ep_events_transfer(ep, events, maxevents)) && jtimeout)
+	if (res>=0 && eavail &&
+	    !(res += ep_events_transfer(ep, events, maxevents-res)) && jtimeout)
 		goto retry;
 
 	return res;
@@ -1705,6 +1818,41 @@
 	return error;
 }
 
+/* Test whether there is any event in the ioctx's event ring */
+static int aio_peak_evt(struct kioctx *ioctx)
+{
+	struct aio_ring_info *info = &ioctx->ring_info;
+	struct aio_ring *ring;
+	int ret = 0;
+
+	if (!info) {
+		DNPRINTK(3, (KERN_ERR "eventpoll: AIO info is NULL!\n"));
+		goto done;
+	}
+	if (!info->ring_pages) {
+		DNPRINTK(3, (KERN_ERR "[%p] eventpoll: AIO info->ring_pages is NULL!, ioctx=%p \n", current, ioctx));
+		goto done;
+	}
+	if (!info->ring_pages[0]) {
+		DNPRINTK(3, (KERN_ERR "eventpoll: AIO info->ring_pages[0] is NULL!\n"));
+		goto done;
+	}
+	ring = kmap_atomic(info->ring_pages[0], KM_USER0);
+	DNPRINTK(3, (KERN_INFO "eventpoll: in aio_peak_evt ring:%lu\n", ring));
+	//	printk("in aio_peak_evt h%lu t%lu m%lu\n",
+	//	 (unsigned long)ring->head, (unsigned long)ring->tail,
+	//	 (unsigned long)ring->nr);
+	barrier();
+	if (ring->head != ring->tail)
+	  ret = 1;
+
+	DNPRINTK(3, (KERN_INFO "eventpoll: leaving aio_read_evt: %d  h%lu t%lu\n", ret,
+		 (unsigned long)ring->head, (unsigned long)ring->tail));
+	kunmap_atomic(ring, KM_USER0);
+done:
+	return ret;
+}
+
 
 static void __exit eventpoll_exit(void)
 {
diff -Nru linux-2.5.70/include/linux/eventpoll.h linux-2.5.70-eepoll/include/linux/eventpoll.h
--- linux-2.5.70/include/linux/eventpoll.h	2003-05-26 18:00:39.000000000 -0700
+++ linux-2.5.70-eepoll/include/linux/eventpoll.h	2003-06-09 18:04:33.000000000 -0700
@@ -24,12 +24,14 @@
 #define EPOLLET (1 << 31)
 
 struct epoll_event {
-	__u32 events;
-	__u64 data;
+  __u32 events;
+  __u64 data;
 };
 
 #ifdef __KERNEL__
 
+#define EPOLLAIO (0x2000)
+
 /* Forward declarations to avoid compiler errors */
 struct file;
 
